unit unit_funcoes;

interface

uses
  Vcl.Forms, Vcl.ExtCtrls, Vcl.Graphics, Vcl.StdCtrls, System.SysUtils,
  Vcl.DBCtrls, Vcl.Mask, Winapi.Windows, Vcl.DBGrids, Vcl.Grids, Data.DB,
  Vcl.ComCtrls, FireDAC.Comp.Client,  udmConn;

  procedure prc_ocultar_tabs( PageControl : TPageControl ) ;
  function SomenteNumeros( AString: String ): String;
  function RemoveCaracteres( AString: String ): String;
  procedure ValidarCampoObrigatorios ( Form : TForm );
  procedure MudarBotao ( Form: Tform; Botao : TPanel );
  function Criptografia( Senha: string ): string;
  function CriarMensagem ( Tipo, MSG: String ) : boolean;

  procedure prcDrawColumnCell( Sender: TObject; const Rect: TRect;
      DataCol: Integer; Column: TColumn; State: TGridDrawState);
  procedure prc_pintar_titulo_coluna( dbg: TDBGrid; Coluna : TColumn );
  procedure prc_ajusta_tamanho_linha ( dbg: TDBGrid );
  procedure prc_ajustar_colunas_grid(const xDBGrid: TDBGrid);
  function fnc_remove_ponto ( Valor: String ): Double;
  function fnc_retorna_valor_generator ( NomeGenerator : String ): Integer;
  procedure prc_ordenar_dgrid( ds: TDataSource; Grid : TDBGrid; Coluna : TColumn );
  function fnc_formata_texto( texto : string; tamanho_maximo: integer ):string;

type
  TDBGridPadrao = class( TCustomGrid );

VAR
  //variaveis globais
  var_gbl_resposta_msg : Boolean;
  var_gbl_versao_app   : String;

implementation

uses unit_mensagem;//  unit_conexao;


function fnc_formata_texto( texto : string; tamanho_maximo: integer ):string;
var
 i,tamanho_texto : integer;
 espaco : string;
begin
  espaco := '';
  i:=0;
  tamanho_texto := Length( texto );

  if tamanho_texto > tamanho_maximo then
    result := copy(texto, 1, tamanho_maximo)
  else if tamanho_texto < tamanho_maximo then
  begin
   // i:= tamanho_maximo - tamanho_texto;
    while I <  (tamanho_maximo - tamanho_texto)  DO
    begin
      espaco := espaco + ' ';
      inc(i);
    end;
    result := texto + espaco
  end else
  if tamanho_texto = tamanho_maximo then
   result := texto;

end;

procedure prc_ordenar_dgrid( ds: TDataSource; Grid : TDBGrid; Coluna : TColumn );
begin
  //quando clica no titulo da coluna do dbgrid muda a ordenação e
  //o campo que a consulta é feita

  //pinta o titulo da coluna que foi clicada
  prc_pintar_titulo_coluna( Grid, Coluna );


  if ( not ( ds.DataSet.IsEmpty ) ) then
  begin
    //ao inves de usar o order by, pode ser ordenado usando a propriedade
    // IndexFieldNames nos componentes TFDQuery - :D corresponde ao decrescente
    if ( ds.DataSet as TFDQuery ).IndexFieldNames = Coluna.FieldName Then
      ( ds.DataSet as TFDQuery ).IndexFieldNames := Coluna.FieldName + ':D'
    else
      ( ds.DataSet as TFDQuery ).IndexFieldNames := Coluna.FieldName;

    //apos realizar a ordenação, coloca o cursor no primeiro campo
    ( ds.DataSet as TFDQuery ).First;

    //ajustas as colunas do dbgrid
    prc_ajustar_colunas_grid( Grid );

    //aumenta o tamanho da linha do ddgrid
    prc_ajusta_tamanho_linha( Grid );
  end;

end;



//funcao que percorre o pagecontrol ocultando as paginas
procedure prc_ocultar_tabs( PageControl : TPageControl ) ;
var
  page: integer;

begin
  //percorre o pagecontrol ocultando pagina por pagina ate o numero total
  for page := 0 to PageControl.PageCount -1 do
    PageControl.Pages [ page ].TabVisible := false;

  //coloca a primeira pagina como ativa
  PageControl.ActivePageIndex := 0;
end;

//funcao que retorna uma string de numeros sem os caracteres caso exista
function SomenteNumeros( AString: String ): String;
var
  I : Integer;
  Limpos : String;
begin

  Limpos := '';

  //percorra a string caracter por caracter
  for I := 1 to Length( AString ) do
  begin

  //verifico se é um numero
    if Pos ( Copy( AString, I, 1 ), '0123456789') > 0 then
      Limpos := Limpos + Copy( AString, i, 1 ); //so copia para a variavel se for numero

  end;

  //retorno para a funcao
  Result := Limpos;
end;

//funcao que retorna uma string sem os caracteres especiais caso exista
function RemoveCaracteres( AString: String ): String;
var
  I : Integer;
  Limpos : String;
begin

  Limpos := '';

  //percorra a string caracter por caracter
  for I := 1 to Length( AString ) do
  begin

  //verifico se é um caracter especial
    if Pos ( Copy( AString, I, 1 ), '"!%$#@&¨*().,;:/<>[]{}=+-_\|') = 0 then
      Limpos := Limpos + Copy( AString, i, 1 ); //so copia para a variavel se nao for caracter

  end;

  //retorno para a funcao
  Result := Limpos;
end;


//funcao que percorre todos os componentes do form vericando
//qual é obrigatorio e qual nao esta preenchido
procedure ValidarCampoObrigatorios ( Form : TForm );
var
  i:Integer;

begin

  //percorre todos os componentes do form
  for I := 0 to Form.ComponentCount - 1 do
  begin

    //se o tag = 99 entao indicara que é componente obrigatorio
    if ( Form.Components[i].Tag = 99 ) then
    begin
      //testando o Tedit
      if ( form.Components[i] is TEdit ) and
         ( ( form.Components[i] as TEdit ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TEdit ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TEdit ).Enabled ) and
         ( ( form.Components[i] as TEdit ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('AVISO','O Campo ' + ( form.Components[i] as TEdit ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TEdit ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TEdit ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TEdit ( form.Components[i] ).Parent );
        end;


        ( form.Components[i] as TEdit ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;


      //testando o TDBedit
      if ( form.Components[i] is TDBEdit ) and     //testando o Tedit
         ( ( form.Components[i] as TDBEdit ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TDBEdit ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TDBEdit ).Enabled ) and
         ( ( form.Components[i] as TDBEdit ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TDBEdit ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TDBEdit ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TDBEdit ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TDBEdit ( form.Components[i] ).Parent );
        end;

        ( form.Components[i] as TDBEdit ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;



      //testando o TComboBox
      if ( form.Components[i] is TComboBox ) and     //testando o Tedit
         ( ( form.Components[i] as TComboBox ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TComboBox ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TComboBox ).Enabled ) and
         ( ( form.Components[i] as TComboBox ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TComboBox ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TComboBox ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TComboBox ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TComboBox ( form.Components[i] ).Parent );
        end;

        ( form.Components[i] as TComboBox ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;


      //testando o TDBComboBox
      if ( form.Components[i] is TDBComboBox ) and     //testando o Tedit
         ( ( form.Components[i] as TDBComboBox ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TDBComboBox ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TDBComboBox ).Enabled ) and
         ( ( form.Components[i] as TDBComboBox ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TDBComboBox ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TDBComboBox ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TDBComboBox ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TDBComboBox ( form.Components[i] ).Parent );
        end;

        ( form.Components[i] as TDBComboBox ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;


      //testando o TDBlookUpComboBox
      if ( form.Components[i] is TDBlookUpComboBox ) and     //testando o Tedit
         ( ( form.Components[i] as TDBlookUpComboBox ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TDBlookUpComboBox ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TDBlookUpComboBox ).Enabled ) and
         ( ( form.Components[i] as TDBlookUpComboBox ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TDBlookUpComboBox ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TDBlookUpComboBox ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TDBlookUpComboBox ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TDBlookUpComboBox ( form.Components[i] ).Parent );
        end;


        ( form.Components[i] as TDBlookUpComboBox ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;


      //testando o TMemo
      if ( form.Components[i] is TMemo ) and     //testando o Tedit
         ( ( form.Components[i] as TMemo ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TMemo ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TMemo ).Enabled ) and
         ( ( form.Components[i] as TMemo ).Text = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TMemo ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TMemo ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TMemo ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TMemo ( form.Components[i] ).Parent );
        end;

        ( form.Components[i] as TMemo ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;


      //testando o TMaskEdit
      if ( form.Components[i] is TMaskEdit ) and     //testando o Tedit
         ( ( form.Components[i] as TMaskEdit ).Hint <> '' ) and //Se a Mensagem do Campo vazio nao estiver em branco
         ( ( form.Components[i] as TMaskEdit ).Visible ) and  //se ele estiver visivel
         ( ( form.Components[i] as TMaskEdit ).Enabled ) and
         ( RemoveCaracteres ( ( form.Components[i] as TMaskEdit ).Text ) = '' ) then //se ele estiver habilitado
      begin
        CriarMensagem ('aviso','O Campo ' + ( form.Components[i] as TMaskEdit ).Hint +
                         ' é de preenchimento obrigatório!'); //avisa o usuario

        if ( TMaskEdit ( form.Components[i] ).Parent.ClassType = TTabSheet ) then
        begin
          //identifiquei que o Componente esta dentro de um tabSheet
          //Tenho que localizar o nome da pagina dele e fazer o pagecontrol
          //deixar essa pagina como sendo a ativa antes de mandar o foco no componente
          TPageControl( TTabSheet ( TMaskEdit ( form.Components[i] ).Parent ).Parent ).ActivePage :=
             TTabSheet ( TMaskEdit ( form.Components[i] ).Parent );
        end;


        ( form.Components[i] as TMaskEdit ).SetFocus; //poe o foco no componente

        Abort;  //aborta para nao executar mais nenhum codigo
      end;

    end;// fim do tag =99

  end; //fim do for que percorre os componentes

end;
procedure MudarBotao ( Form: Tform; Botao : TPanel );
var
  i: Integer;

begin
// jocelio cada botao( label, imagem, e panel tem que ter seu tag iguais e diferente dos demais

  //percorre todos os componentes do formulario
  for i:= 0 to Form.ComponentCount - 1 do
  begin
     //selecionando os label tag <> de 0, indicando que sao labels dos botoes
     if ( Form.Components[i] is TLabel ) and
        ( ( Form.Components[i] as TLabel ).Tag > 0 ) then
     begin

       //se a tag do label =  a do botao focado entao mud a cor
       if ( Botao as TPanel ).Tag = ( Form.Components[i] as TLabel ).Tag then
       begin
         ( Form.Components[i] as TLabel ).Font.Color := $000080FF;
         ( Form.Components[i] as TLabel ).Font.Style := [fsBold];
       end else //nao tem a mesma tage entao é label dos outros botoes
       begin
         ( Form.Components[i] as TLabel ).Font.Color := clWhite;
         ( Form.Components[i] as TLabel ).Font.Style := [];
       end;

     end;


    //voltar a cor original de todos os outros botoes
    if ( Form.Components[i] is TPanel ) and
       (
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_menulateral' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_pessoas' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_produtos' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_faturamento' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_compras' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_estoques' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_sistema' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_financeiro' ) or
         ( ( ( Form.Components[i] as TPanel ).Parent ).Name = 'pnl_submenu_utilitarios' )
       ) then
    begin
       ( Form.Components[i] as TPanel ).Color := $00191919;
    end;

  end;

  //muda a cor do panel focado para um tom mais escuro
  ( Botao as TPanel ).Color      := $00141414;
end;

//funcao que gera uma sequencia de caracteres a partir de uma chave
function Criptografia( Senha: string ): string;
var
  x,y : Integer;
  Chave, NovaSenha : String;

begin
  Chave:= 'EmissorNFE';

  //percorre a chave caracter por caracter
  for x := 1 to Length( Chave ) do
  begin

    //limpa a variavel temporaria
    NovaSenha := '';

    //percorre a senha passado por parametro caracter por caracter
    for y := 1 to Length( Senha ) do
    begin
      //realiza operacoes logicas para trocar caracteres da senha por outros
      NovaSenha := NovaSenha + chr( ( Ord( Chave[x] ) xor Ord( Senha[y] ) ) );
    end;

    //A senha passada por parametro recebe o resultado das opeaçoes logicas
    Senha := NovaSenha;
  end;

  //o resultado da senha é passado para o retorno da funcao
  Result := Senha;
end;


function CriarMensagem ( Tipo, MSG: String ) : boolean;
begin

  //inicializa o retorno da funcao
  Result := False;

  Try
    //cria o form mensagem
    form_mensagem       := TForm_mensagem.Create ( nil );

    //passa para o form o tipo de mensagem e o texto que deseja mostrar
    form_mensagem.sTipo := Tipo;
    form_mensagem.lbl_descricao.caption   := MSG;

    if length( MSG ) > 50 then
      form_mensagem.lbl_descricao.Font.Size := 12;

    // mostra o form
    form_mensagem.ShowModal;

    //retorna para funcao a resposta SIM OU NAO do usuario
    Result := var_gbl_resposta_msg;

    //reinicializa o valor da variavel
    var_gbl_resposta_msg := False;
  Finally

    //libera o form da memoria
    FreeandNil (form_mensagem);

  End;

end;

//prcedure responsavel por mudar a cor da selecao e zebrar um dbgrid
procedure prcDrawColumnCell( Sender: TObject; const Rect: TRect;
  DataCol: Integer; Column: TColumn; State: TGridDrawState);
begin

  //zebrando o dbgrid
  if Odd( ( Sender as TDbgrid ).DataSource.DataSet.RecNo) then
    ( Sender as TDbgrid ).Canvas.Brush.Color :=  $00FBFBFB
  else
    ( Sender as TDbgrid ).Canvas.Brush.Color := clwhite;//$00F9F9F9;


  //mudando a cor da seleção
  if ( gdSelected in State ) then
  begin
    ( Sender as TDbgrid ).Canvas.Brush.Color := $00FFE8CC; //cor da linha
    ( Sender as TDbgrid ).Canvas.Font.Color  := clBlack;   //cor da fonte
    ( Sender as TDbgrid ).Canvas.Font.Style  := [fsBold];  //estilo da fonte
  end;

  ( Sender as TDbgrid ).Canvas.FillRect(Rect);
  ( Sender as TDbgrid ).DefaultDrawColumnCell( Rect, DataCol, Column, State);

  //mudando a posicao e alinhamento vertical do texto de cada linha
  if Column.Field.DataType = ftBCD then
    ( Sender as TDbgrid ).Canvas.TextRect( Rect, Rect.Left - 8 + ( Rect.Width - (( Sender as TDbgrid ).Canvas.TextWidth ( Column.Field.DisplayText ) ) ), Rect.Top + 8 , Column.Field.DisplayText )
  else
    ( Sender as TDbgrid ).Canvas.TextRect( Rect, Rect.Left + 8, Rect.Top + 8, Column.Field.DisplayText );

end;


//procedure que pinta o titulo da coluna que esta sendo usada para ordenar os dados no dbgrid
procedure prc_pintar_titulo_coluna( dbg: TDBGrid; Coluna : TColumn );
var
  i:Integer;

begin

  //pintando o titulo da coluna do dbgrid
  for I := 0 to dbg.Columns.Count - 1  do
  begin
    if dbg.Columns[i].FieldName = Coluna.FieldName then
    begin
       //se for a coluna enviada por parametro entao mudo a cor do titulo (fonte)
      dbg.Columns[i].Title.Font.Color := clRed;  //cor da fonte
      dbg.Columns[i].Title.Font.Style := [fsBold]; //estilo da fonte
    end else
    begin
      // se nao for coloca no padrao
      dbg.Columns[i].Title.Font.Color := clBlack;
      dbg.Columns[i].Title.Font.Style := [];
    end;
  end;

end;

//aumenta o tamanho da linha do dbgrid sem mudar a fonte
procedure prc_ajusta_tamanho_linha (dbg: TDBGrid );
begin
  //Define o tamanho de cada linha do dbgrid apos ativar a query
  TDBGridPadrao(dbg).DefaultRowHeight := 30;
  TDBGridPadrao(dbg).ClientHeight     := ( 30 * TDBGridPadrao(dbg).RowCount ) + 30;

  TDBGridPadrao(dbg).RowHeights[0] := 30;
end;


//funcao para ajustar as colunas do dbgrid de acordo com o tamanho da tela
procedure prc_ajustar_colunas_grid(const xDBGrid: TDBGrid);
var
  I, TotalWidht, VarWidth, QtdTotalColuna : Integer;
  xColumn : TColumn;
begin

  //sempre mostro a barra lateral do dbgrid
  ShowScrollBar( xDBGrid.Handle,SB_Vert, True );


  //percorre o dbgrid alterando a tag da coluna que possuir o nome abaixo
  For I := 0 to xDBGrid.FieldCount - 1 do
  begin

    if ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'NOME' ) or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'ENDERECO' ) or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'HISTORICO' ) or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'NOME_FANTASIA' )or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'BAIRRO' )or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'DS_ENDERECO' )or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'DS_MUNICIPIO' )or
       ( UpperCase( xDBGrid.Fields[I].FieldName ) = 'DS_NOME' ) then
      xDBGrid.Fields[I].Tag := 30 //pode ser qualquer valor, é so pra diferenciar a coluna
    else
      xDBGrid.Fields[I].Tag := 0;

  end;

  // Largura total de todas as colunas antes de redimensionar
  TotalWidht := 0;

  // Quantas colunas devem ter auto-redimensionamento
  QtdTotalColuna := 0;

  //percorre o dbgrid para descobrir o tamanho total dele e a quantidade de
  //colunas que irao mudar de tamanho
  for I := 0 to -1 + xDBGrid.Columns.Count do
  begin
    TotalWidht := TotalWidht + xDBGrid.Columns[I].Width;

    if xDBGrid.Columns[I].Field.Tag <> 0 then
      Inc( QtdTotalColuna );
  end;

  // Adiciona 1px para a linha de separador de coluna
  if dgColLines in xDBGrid.Options then
    TotalWidht := TotalWidht + xDBGrid.Columns.Count;

  // width vale "Left"
  VarWidth :=  xDBGrid.ClientWidth - TotalWidht;

  // Da mesma forma distribuir VarWidth para todas as colunas auto-resizable
  if QtdTotalColuna > 0 then
    VarWidth := varWidth div QtdTotalColuna;

  //redimensionando as colunas
  for I := 0 to -1 + xDBGrid.Columns.Count do
  begin
    xColumn := xDBGrid.Columns[I];

    if xColumn.Field.Tag <> 0 then
    begin
      xColumn.Width := xColumn.Width + VarWidth;

      if xColumn.Width < xColumn.Field.Tag then
        xColumn.Width := xColumn.Field.Tag;
    end;
  end;

end;

function fnc_remove_ponto ( Valor: String ): Double;
var
  i: Integer;
  NovoValor : String;

begin
  //função que remove o ponto "." de um valor monetario
  NovoValor := '';

  if Valor = '' then Valor := '0,00';

  //percorre a string valor procurando por "." se encontrar nao copia para NovoValor
  for I := 1 to Length ( Valor ) do
  begin

    if Valor [I] <> '.' then
      NovoValor := NovoValor + Valor [I];

  end;

  //retorna o valor sem o ponto
  Result := StrToFloat ( NovoValor );

end;

function fnc_retorna_valor_generator ( NomeGenerator : String ): Integer;
var
  QryAuxiliar: TFDQuery;

begin
  //função que retorna o valor de um gerador
  Result := 0;

  try
    QryAuxiliar := TFDQuery.Create( nil );
    QryAuxiliar.Close;
    QryAuxiliar.Connection := dmConn.FDConnection;// form_conexao.FDConnection;
    QryAuxiliar.SQL.Clear;
    QryAuxiliar.SQL.Add(' select gen_id( '+NomeGenerator+', 0 ) As Valor from rdb$database ');
    QryAuxiliar.Open;

    if not QryAuxiliar.isempty then
      Result:= QryAuxiliar.FieldByName('Valor').AsInteger + 1;

  finally
    QryAuxiliar.Free;
  end;

end;



end.
