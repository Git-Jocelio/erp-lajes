unit uAtualizaSistema;

interface

uses
  Winapi.Windows,
  Vcl.Forms,
  System.SysUtils,
  Vcl.Dialogs,
  Winapi.Messages,
  Winapi.ShellAPI,
  System.Classes;


{cria o nome de um caminho temporario chamado de UpdateLive
dentro da pasta Temp do windows}
function GetWindowsTemp : string;

{cria no do disco o diretorio updateLive}
function CriarDiretorio(diretorioTemp : string) : boolean;

function GetTmpDir: string;

function ExtractName(const FileName: string): string;

function GetTmpFileName(ext : string): string;

procedure KillProcess( servidor: string; hWindowHandle: HWnd; nome: string);

function fnc_atualiza_sistema(servidor : string): boolean;


implementation


function CriarDiretorio(diretorioTemp: string): boolean;
var
  SHFileOpStruct : TSHFileOpStruct;// precisa da biblioteca ShellApi
  DirBuf : array [0..255] of char;
begin
  result := false;
  if DirectoryExists(diretorioTemp) then
  begin
    try
      FillChar(SHFileOpStruct, sizeof(SHFileOpstruct), 0);
      FillChar(DirBuf, sizeof(DirBuf), 0);
      StrPCopy(DirBuf, diretorioTemp);
      with SHFileOpstruct do
      begin
        wnd    := 0;
        pFrom  := @DirBuf;
        wFunc  := FO_DELETE;
        fFlags := FOF_ALLOWUNDO;
        fFlags := fFlags or FOF_NOCONFIRMATION;
        fFlags := fFlags or FOF_SILENT;

      end;
      Application.ProcessMessages;
      Result := ( SHFileOperation(SHFileOpStruct) = 0);
      System.SysUtils.CreateDir(diretorioTemp);
      Application.ProcessMessages;
    except
      result := false;
    end;
  end
  else
  begin

    System.SysUtils.CreateDir(diretorioTemp);
    Application.ProcessMessages;
    result := false;

  end;
end;


function ExtractName(const FileName: string) : string;
var
  aExt : string;
  aPos : integer;
begin
  Application.ProcessMessages;
  aExt := ExtractFileExt(FileName);
  Result := ExtractFileName(FileName);
//ShowMessage('result extractName ' + Result);
  if aExt <> '' then
  begin
    aPos := pos(aExt, Result);
    if aPos > 0 then
    begin
      delete(Result, aPos, length(aExt));
    end;
  end;
  Application.ProcessMessages;

end;


function GetTmpDir: string;
var
  pc : PChar;
begin

  Application.ProcessMessages;
  pc := StrAlloc(MAX_PATH + 1 );
  GetTempPath(MAX_PATH, pc);
  result := string(pc);
  StrDispose(pc);

end;


function GetWindowsTemp: string;
var
  Buffer : array[0.. Max_path] of Char;
begin

  FillChar(Buffer, max_path + 1, 0);
  GetTempPath(MAX_PATH, Buffer);
  Result := String(buffer);

  if result [length(result)] <> '\'then
    result := Result + '\';

  Result := Result + 'UpDateLive\';

end;

function GetTmpFileName(ext: string): string;
var
  pc : PChar;
begin

  Application.ProcessMessages;
  pc := StrAlloc(MAX_PATH +1 );
  GetTempFileName(PChar(GetTmpDir), 'EZC', 0, pc);
  result := string(pc);
  result := ChangeFileExt(result, ext);
  StrDispose(pc);

end;

procedure KillProcess( servidor: string; hWindowHandle : HWnd; nome : string);
var
  hprocessId : integer;
  processHandle : THandle;
  DWResult : DWORD;
  dir : string;
  EXE : string;
begin
  SendMessageTimeout(hWindowHandle, WM_CLOSE, 0,0,SMTO_ABORTIFHUNG OR SMTO_NORMAL, 5000, DWResult);

  if IsWindow(hWindowHandle) then
  begin

    GetWindowThreadProcessId(hWindowHandle, @hprocessId);
    if hprocessId <> 0 then
    begin

      processHandle := OpenProcess(PROCESS_TERMINATE or PROCESS_QUERY_INFORMATION, false, hprocessId);
      if processHandle <> 0 then
      begin
        dir := ExtractFilePath(nome);
        EXE := ExtractFileName(nome);

        ShellExecute(0,nil,pwidechar(EXE), NIL,PWIDECHAR(dir), sw_hide);
        TerminateProcess(processHandle,0);
        CloseHandle(processHandle);
      end;

    end;

  end;

end;

function fnc_atualiza_sistema( servidor: string ): boolean;
var
  dirTemp : string;
  lista   : TStrings;
  nomeBAT : string;
  nomeDOS : string;

begin

  result := false;
  nomeDOS := Application.ExeName;

  {cria o caminho do diretorio a ser criado}
  dirTemp := uAtualizaSistema.GetWindowsTemp;
  {cria uma pasta no diretorio temp do windows}
  uAtualizaSistema.CriarDiretorio(dirTemp);

ShowMessage(servidor + Application.ExeName);

  //if FileExists('192.168.100.32:' + Application.ExeName) then   //verifica se o arquivo existe no servidor
  if FileExists(servidor + Application.ExeName) then   //verifica se o arquivo existe no servidor
  begin
    {origem "servidor" / destino "diretorio temporario local"}
    //CopyFile( PChar('192.168.99.53:' + Application.ExeName ),
    CopyFile( PChar( servidor + Application.ExeName ),
              PChar( dirTemp + ExtractName(nomeDOS) + '.Exe' ), true );

    {copiar o sistema transferido para a pasta local para
    a pasta onde o sistema roda. (trocando a extesão de exe. para tmp) }

    //if FileExists(edt_diretorio_temp.Text + 'App.Exe') then
    if FileExists( dirTemp + ExtractName(nomeDOS) + '.Exe') then
    begin
      {origem"diretorio temporario" / destino "diretorio do sistema"}
      CopyFile(
              //PChar( edt_diretorio_temp.Text + 'App.Exe'),
              PChar( dirTemp + ExtractName(nomeDOS) + '.Exe'),
              PChar( ChangeFileExt(nomeDOS , '.tmp') ),
              true
               );// copia trocando a extensão

      //ShowMessage('copiou o arquivo para o diretorio do sistema trocando a extensão');


      {atualizar o executavel através de um arquivo BAT, crido na pasta windows/ temp}
      //nomeDOS := Application.ExeName;
      //nomeDOS := 'C:\update\' + 'App.Exe'; // exe a ser atualizado
      //ShowMessage(ExtractFilePath(nomeDOS) + uAtualizaSistema.ExtractName(nomeDOS) + '.tmp');
      lista := TStringList.Create;
      try
        lista.Clear;
        nomeBAT := uAtualizaSistema.GetTmpFileName('.bat');
        lista.Add(':Label1');
        lista.Add('@echo off');
        lista.Add('del ' + nomeDOS);
        lista.Add('if Exist ' + nomeDOS + ' goto Label1');
        //lista.Add('Move ' + ExtractFilePath(Application.ExeName) + ExtractName(nomeDOS + '.tmp') );
        lista.Add('Move ' + ExtractFilePath(nomeDOS) + uAtualizaSistema.ExtractName(nomeDOS) + '.tmp' + ' ' + nomeDOS );
        lista.Add('TIMEOUT  5');
        lista.Add('Call ' + nomeDOS);
        lista.Add('del ' + nomeBAT);
        lista.SaveToFile(nomeBAT);
        Application.ProcessMessages;
        ChDir(uAtualizaSistema.GetTmpDir);
        uAtualizaSistema.KillProcess( servidor, Application.Handle, nomeBAT);
        Application.Terminate;
        Abort;
      finally
        result := true;
        FreeAndNil( lista );
      end;
    end;
  end
  else
  begin
    ShowMessage('arquivo NÃO encontrado');
  end;
end;


end.
